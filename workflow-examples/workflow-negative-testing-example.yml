description: Example workflow demonstrating negative testing with expected failures
name: Negative Testing Example

# Force pull Docker images even if they exist locally
force_pull_image: true
near_devnet: true
contracts_dir: contracts/near

nodes:
  chain_id: testnet-1
  count: 2
  image: ghcr.io/calimero-network/merod:edge
  prefix: calimero-node

steps:
  # Step 1: Install the application on the first node
  - name: Install Application on Node 1
    type: install_application
    node: calimero-node-1
    path: workflow-examples/res/kv_store.wasm
    dev: true
    outputs:
      app_id: applicationId

  # Step 2: Create a context using the installed application
  - name: Create Context on Node 1
    type: create_context
    node: calimero-node-1
    application_id: "{{app_id}}"
    outputs:
      context_id: contextId
      member_public_key: memberPublicKey

  # Step 3: Execute a call that will fail - using an invalid method
  # This demonstrates expected failure handling when a method doesn't exist
  - name: Expected Failure - Invalid Method
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: invalid_method_that_does_not_exist
    args: {}
    expected_failure: true
    outputs:
      error_code: error_code # Extract error code from JSON-RPC error
      error_type: error_type # Extract error type
      error_message: error_message # Extract error message
      error: error # Full error object

  # Step 4: Assert that we got an error (error_type should be set)
  - name: Assert Error Occurred
    type: assert
    statements:
      - statement: "is_set({{error_type}})"
        message: "Expected an error to occur (error_type should be set)"
      - statement: "equal({{error_type}}, FunctionCallError)"
        message: "Expected FunctionCallError type"
      - statement: "contains({{error_message}}, not found)"
        message: "Expected error message to contain 'not found'"

  # Step 5: Set a key successfully
  - name: Successful Call - Set Key
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: set
    args:
      key: test_key
      value: test_value
    outputs:
      set_result: result

  # Step 6: Expected failure - wrong executor public key
  - name: Expected Failure - Unauthorized Access
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: invalid_public_key_12345
    method: set
    args:
      key: unauthorized_key
      value: unauthorized_value
    expected_failure: true
    outputs:
      auth_error_code: error_code
      auth_error_type: error_type
      auth_error_message: error_message

  # Step 7: Verify successful call still works
  - name: Successful Call - Get Key
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: get
    args:
      key: test_key
    outputs:
      get_result: result

  # Step 8: Expected failure - invalid arguments (missing required field)
  - name: Expected Failure - Invalid Arguments
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: set
    args:
      key: missing_value_key
      # Missing 'value' field - should cause an error
    expected_failure: true
    outputs:
      invalid_args_error_type: error_type
      invalid_args_error_message: error_message

  # Step 9: Expected failure - invalid context ID
  - name: Expected Failure - Invalid Context ID
    type: call
    node: calimero-node-1
    context_id: invalid_context_id_12345
    executor_public_key: "{{member_public_key}}"
    method: get
    args:
      key: test_key
    expected_failure: true
    outputs:
      invalid_context_error_type: error_type
      invalid_context_error_code: error_code
      invalid_context_error_message: error_message

  # Step 10: Expected failure - wrong argument types
  - name: Expected Failure - Wrong Argument Types
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: set
    args:
      key: 12345 # Should be string, not number
      value: test_value
    expected_failure: true
    outputs:
      type_error_type: error_type
      type_error_message: error_message

  # Step 11: Expected failure - method exists but wrong number of arguments
  - name: Expected Failure - Missing Required Argument
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: get
    args: {} # Missing 'key' argument
    expected_failure: true
    outputs:
      missing_arg_error_type: error_type
      missing_arg_error_message: error_message

  # Step 12: Test that expected failure with no outputs still works
  - name: Expected Failure - No Outputs Configured
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: invalid_method_no_outputs
    args: {}
    expected_failure: true
    # No outputs - should still handle error gracefully

  # Step 13: Verify successful operations still work after failures
  - name: Successful Call - Set Another Key
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: set
    args:
      key: final_test_key
      value: final_test_value
    outputs:
      final_set_result: result

  # Step 14: Assert on multiple error types captured
  # Note: Some errors may be network-level (no error_code/error_type) or JSON-RPC level
  - name: Assert Multiple Error Types
    type: assert
    statements:
      - statement: "is_set({{error_type}})"
        message: "First error (invalid method) should have error_type set"
      - statement: "is_set({{auth_error_message}})"
        message: "Auth error should have error_message set (may be network or JSON-RPC error)"
      - statement: "is_set({{invalid_args_error_type}})"
        message: "Invalid args error should have error_type set"
      - statement: "is_set({{invalid_context_error_message}})"
        message: "Invalid context error should have error_message set (may be network or JSON-RPC error)"

  # Step 15: Test expected failure when call succeeds (should warn but continue)
  # This tests that None values are properly exported for both simple and complex dict syntax
  - name: Expected Failure But Call Succeeds
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: get
    args:
      key: test_key
    expected_failure: true # This should succeed, but we expect failure
    outputs:
      # Simple string assignments (should export None)
      unexpected_success_error_type: error_type # Should be None
      unexpected_success_error_code: error_code # Should be None
      # Complex dict-based assignments (should export None - this tests the fix)
      unexpected_success_complex_error_type:
        field: error_type
      unexpected_success_complex_error_code:
        field: error_code
        target: unexpected_error_code_{node_name}
      unexpected_success_complex_error_message:
        field: error_message

  # Step 16: Assert that unexpected success exported None values
  # Note: When expected_failure is True but call succeeds, error fields are exported as None
  # This tests both simple and complex dict syntax export None values correctly
  - name: Assert Unexpected Success Handled
    type: assert
    statements:
      - statement: "is_empty({{unexpected_success_error_type}})"
        message: "When expected failure doesn't occur, error_type should be None/empty (simple syntax)"
      - statement: "is_empty({{unexpected_success_error_code}})"
        message: "When expected failure doesn't occur, error_code should be None/empty (simple syntax)"
      - statement: "is_empty({{unexpected_success_complex_error_type}})"
        message: "When expected failure doesn't occur, complex error_type should be None/empty"
      - statement: "is_empty({{unexpected_error_code_calimero-node-1}})"
        message: "When expected failure doesn't occur, complex error_code with custom target should be None/empty"
      - statement: "is_empty({{unexpected_success_complex_error_message}})"
        message: "When expected failure doesn't occur, complex error_message should be None/empty"

  # Step 17: Test complex output syntax for error fields
  # This demonstrates that complex dict-based output syntax works for error fields
  - name: Expected Failure - Complex Output Syntax
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: invalid_method_complex_test
    args: {}
    expected_failure: true
    outputs:
      # Simple string assignment
      simple_error_type: error_type
      # Complex dict-based assignment
      complex_error:
        field: error_type
      complex_error_code:
        field: error_code
        target: custom_error_code_{node_name}
      complex_error_message:
        field: error_message

  # Step 18: Assert complex output syntax exported error fields correctly
  # Note: error_code may be None for some JSON-RPC errors (Calimero uses type/data, not always code)
  # The export mechanism is verified by: (1) terminal output shows export message, (2) is_empty() verifies
  # the variable was exported (if not exported, unresolved placeholder would be a non-empty string, causing failure)
  - name: Assert Complex Output Syntax
    type: assert
    statements:
      - statement: "is_set({{simple_error_type}})"
        message: "Simple error_type assignment should work"
      - statement: "is_set({{complex_error}})"
        message: "Complex dict-based error_type assignment should work"
      - statement: "is_empty({{custom_error_code_calimero-node-1}})"
        message: "Complex error_code with custom target should be exported as None (export verified by terminal output and is_empty check)"
      - statement: "is_set({{complex_error_message}})"
        message: "Complex error_message assignment should work"
      - statement: "equal({{simple_error_type}}, FunctionCallError)"
        message: "Simple assignment should export FunctionCallError"
      - statement: "equal({{complex_error}}, FunctionCallError)"
        message: "Complex assignment should export FunctionCallError"

  # Step 19: Test that error field exports are protected from overwriting
  # Test scenario: Export error_type to a key, then also export result to potentially
  # the same key. The error field export should be protected and remain None.
  - name: Expected Failure But Succeeds - Protected Error Fields
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: get
    args:
      key: test_key
    expected_failure: true # This should succeed, but we expect failure
    outputs:
      # Export error fields first (should be None)
      # These keys will be marked as protected
      protected_error_type: error_type # Should remain None, protected from overwriting
      protected_error_code: error_code # Should remain None, protected from overwriting
      # Export result field to a different key (this should work normally)
      protected_result: result # Should export the actual result value

  # Step 20: Assert that protected error fields were not overwritten
  - name: Assert Protected Error Fields Not Overwritten
    type: assert
    statements:
      - statement: "is_empty({{protected_error_type}})"
        message: "Error field 'protected_error_type' should remain None (protected from overwriting by result data)"
      - statement: "is_empty({{protected_error_code}})"
        message: "Error field 'protected_error_code' should remain None (protected from overwriting by result data)"
      - statement: "is_set({{protected_result}})"
        message: "Non-error field 'protected_result' should still export successfully (not protected)"
      - statement: "contains({{protected_result}}, test_value)"
        message: "Result field should contain the actual result value (not None)"

  # Step 21: Test protection with complex output syntax
  # This tests that the protection mechanism also works with complex dict-based
  # output syntax, ensuring custom target keys are also protected.
  - name: Expected Failure But Succeeds - Protected Complex Error Fields
    type: call
    node: calimero-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{member_public_key}}"
    method: get
    args:
      key: test_key
    expected_failure: true # This should succeed, but we expect failure
    outputs:
      # Complex dict syntax for error fields (with custom targets)
      # These should be protected from overwriting
      protected_complex_error_type:
        field: error_type
        target: custom_protected_error_type_{node_name}
      protected_complex_error_code:
        field: error_code
        target: custom_protected_error_code_{node_name}
      # Regular result export (should work)
      protected_complex_result: result

  # Step 22: Assert that complex error field exports are protected
  - name: Assert Protected Complex Error Fields Not Overwritten
    type: assert
    statements:
      - statement: "is_empty({{custom_protected_error_type_calimero-node-1}})"
        message: "Complex error field with custom target should remain None (protected)"
      - statement: "is_empty({{custom_protected_error_code_calimero-node-1}})"
        message: "Complex error code with custom target should remain None (protected)"
      - statement: "is_set({{protected_complex_result}})"
        message: "Non-error result field should still export successfully"

# Configuration options
stop_all_nodes: false
restart: false
wait_timeout: 60
